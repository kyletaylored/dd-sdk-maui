name: Deploy Docs + NuGet Feed to GitHub Pages

# This workflow runs when:
# 1. Documentation files are pushed to main (docs/** or _config.base.yml) - rebuilds docs + full feed
# 2. A GitHub release is published - rebuilds docs + full feed with new release
# 3. Manually triggered via workflow_dispatch - rebuilds everything
#
# Strategy: Always rebuild the complete NuGet feed from ALL releases
# This ensures the feed is always up-to-date and consistent with GitHub Releases

on:
  push:
    branches: ["main"]
    paths:
      - "docs/**"
      - "_config.base.yml"
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Workflow trigger info
        run: |
          echo "## Workflow Trigger" >> $GITHUB_STEP_SUMMARY
          echo "Event: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" = "release" ]; then
            echo "Release tag: ${{ github.event.release.tag_name }}" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“¦ Will update NuGet feed with release packages" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ github.event_name }}" = "push" ]; then
            echo "ðŸ“ Documentation update - NuGet feed will be preserved" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ”§ Manual trigger - NuGet feed will be preserved" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Checkout
        uses: actions/checkout@v6

      # --- Pages vars (origin/base_path) ---
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5

      # --- Generate Jekyll config dynamically (keep your current approach) ---
      - name: Generate Jekyll config from template
        run: |
          cp docs/_config.base.yml docs/_config.yml

          cat >> docs/_config.yml << 'EOF'

          # --- dynamically injected by GitHub Actions ---

          url: "${{ steps.pages.outputs.origin }}"
          baseurl: "${{ steps.pages.outputs.base_path }}"
          repository: "${{ github.repository }}"

          aux_links:
            "View source on GitHub":
              - "${{ github.server_url }}/${{ github.repository }}"
            "Report an Issue":
              - "${{ github.server_url }}/${{ github.repository }}/issues/new"
            "NuGet Feed":
              - "${{ steps.pages.outputs.origin }}${{ steps.pages.outputs.base_path }}/nuget/index.json"


          aux_links_new_tab: true

          gh_edit_link: true
          gh_edit_link_text: "Edit this page on GitHub"
          gh_edit_repository: "${{ github.server_url }}/${{ github.repository }}"
          gh_edit_branch: "${{ github.ref_name }}"
          gh_edit_source: "docs"
          gh_edit_view_mode: "edit"
          EOF

          echo "Generated docs/_config.yml:"
          tail -n +1 docs/_config.yml

      # --- Build NuGet feed into _site/nuget ---
      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "8.0.x"

      - name: Download ALL release packages
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p pkgs

          # Get all SDK releases (excluding symbols-only releases)
          echo "Fetching all SDK releases..."
          RELEASES=$(gh release list --limit 100 | grep -v "symbols-v" | awk '{print $1}' || echo "")

          if [ -z "$RELEASES" ]; then
            echo "No SDK releases found yet"
          else
            echo "Found SDK releases:"
            echo "$RELEASES"
            echo ""

            # Download packages from each release
            echo "$RELEASES" | while read -r tag; do
              if [ -n "$tag" ]; then
                echo "Downloading packages from release $tag..."
                gh release download "$tag" \
                  --pattern "*.nupkg" \
                  --dir ./pkgs \
                  --skip-existing || echo "No packages in $tag (or already downloaded)"
              fi
            done
          fi

          echo ""
          echo "Total packages downloaded:"
          find ./pkgs -name "*.nupkg" 2>/dev/null | wc -l || echo "0"

      - name: Download ALL Symbols package releases
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p pkgs
          echo "Fetching all Symbols package releases..."
          SYMBOLS_RELEASES=$(gh release list --limit 100 | grep "symbols-v" | awk '{print $1}' || echo "")

          if [ -z "$SYMBOLS_RELEASES" ]; then
            echo "No Symbols package releases found yet"
          else
            echo "Found Symbols releases:"
            echo "$SYMBOLS_RELEASES"
            echo ""

            # Download Symbols packages from each release
            echo "$SYMBOLS_RELEASES" | while read -r tag; do
              if [ -n "$tag" ]; then
                echo "Downloading Symbols package from release $tag..."
                gh release download "$tag" \
                  --pattern "*.nupkg" \
                  --dir ./pkgs \
                  --skip-existing || echo "No packages in $tag (or already downloaded)"
              fi
            done
          fi

      - name: Install Sleet
        run: dotnet tool install -g sleet

      - name: Generate sleet.json dynamically (baseURI uses Pages origin + base_path)
        run: |
          # Build feed in temp location to avoid Jekyll permission issues
          cat > sleet.json <<'JSON'
          {
            "username": "github-actions[bot]",
            "useremail": "github-actions[bot]@users.noreply.github.com",
            "sources": [
              {
                "name": "pages",
                "type": "local",
                "path": "./nuget-temp",
                "baseURI": "__BASEURI__"
              }
            ]
          }
          JSON

          BASEURI="${{ steps.pages.outputs.origin }}${{ steps.pages.outputs.base_path }}/nuget/"
          # safe string replace
          python - <<PY
          import pathlib
          p = pathlib.Path("sleet.json")
          s = p.read_text()
          s = s.replace("__BASEURI__", "${BASEURI}")
          p.write_text(s)
          print("baseURI:", "${BASEURI}")
          PY

      - name: Init NuGet feed
        run: |
          echo "Initializing NuGet feed in temp location..."
          mkdir -p nuget-temp
          sleet init --config sleet.json --source pages
          echo "Feed initialized"

      - name: Push packages to feed
        run: |
          # Count packages
          PKG_COUNT=$(find ./pkgs -name "*.nupkg" 2>/dev/null | wc -l || echo "0")
          echo "Found $PKG_COUNT packages to push"

          if [ "$PKG_COUNT" -gt 0 ]; then
            echo "Pushing packages to feed..."
            sleet push ./pkgs --config sleet.json --source pages --skip-existing
            echo "Packages pushed to feed"

            echo "## NuGet Feed Update" >> $GITHUB_STEP_SUMMARY
            echo "Pushed $PKG_COUNT package(s) to feed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Packages:" >> $GITHUB_STEP_SUMMARY
            find ./pkgs -name "*.nupkg" -exec basename {} \; | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          else
            echo "No packages to push (docs-only update)"
            echo "## NuGet Feed Update" >> $GITHUB_STEP_SUMMARY
            echo "No new packages (existing feed preserved)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Build packages index for NuGet Explorer
        run: |
          python - <<'PY'
          import json
          import os
          from pathlib import Path

          root = Path("nuget-temp/flatcontainer")
          out = Path("nuget-temp/packages.json")
          out.parent.mkdir(parents=True, exist_ok=True)

          packages = []
          if root.exists():
            for pkg_dir in sorted([p for p in root.iterdir() if p.is_dir()], key=lambda p: p.name):
              pkg_id = pkg_dir.name
              versions = []
              prerelease_versions = []
              for ver_dir in sorted([p for p in pkg_dir.iterdir() if p.is_dir()], key=lambda p: p.name):
                v = ver_dir.name
                versions.append(v)
                if "-" in v:
                  prerelease_versions.append(v)

              latest = versions[-1] if versions else None
              latest_stable = None
              for v in reversed(versions):
                if "-" not in v:
                  latest_stable = v
                  break

              packages.append({
                "id": pkg_id,
                "versions": versions,
                "latest": latest,
                "latestStable": latest_stable,
                "hasPrerelease": len(prerelease_versions) > 0
              })

          data = {
            "generatedAtUtc": __import__("datetime").datetime.utcnow().isoformat() + "Z",
            "count": len(packages),
            "packages": packages
          }
          out.write_text(json.dumps(data, indent=2))
          print(f"Wrote {out} with {len(packages)} packages")
          PY

      - name: Move nuget feed to docs directory
        run: |
          echo "Moving NuGet feed from temp location to docs/nuget..."
          mv nuget-temp docs/nuget
          echo "Feed moved to docs/nuget"

      # --- Build docs site ---
      - name: Build with Jekyll
        uses: actions/jekyll-build-pages@v1
        with:
          source: ./docs
          destination: ./_site
          future: false
          verbose: true

      # --- Upload Pages artifact ---
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./_site

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
